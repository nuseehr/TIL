# Inheritance & Composition

**상속의 문제점: 캡슐화 약화, 개방폐쇄원칙**

상속받은 클래스는 부모 클래스의 `public`, `protected` 메소드에 접근이 가능하기 때문에 부모 클래스의 **구현사항에 강하게 의존하게 된다**. 허나 자식 클래스 설계원칙에 부합하지 않는 메소드가 부모클래스에 존재한다면, 그 메소드 또한 자식 클래스로 상속되기 때문에 문제가 발생한다. 완벽한 캡슐화를 원한다면 상속을 포기하거나 적절한 `private` 사용으로 인터페이스 은닉과 함께 `getter`, `setter` 코드 구현 등 정확하게 상속을 구현해내야 한다.

**상속의 문제점: 설계가 유연하지 않다, 클래스간 결합 문제**

상속을 흔히 **확장성**에 유리하다고 알려져있다. ****이것은 상속이 자식 클래스에 기능을 점진적으로 추가하며 확장하는 목적으로는 편리하다는 것을 의미한다. 그러나 상속받은 자식 클래스는 부모클래스와 상호 간의 의존성(결합도, coupling)이 생긴다. 객체지향 프로그래밍에서는 클래스 간 결합도를 낮추고 해당 클래스가 갖는 책임에 집중(응집도, cohesion)하여 독립성을 높이는 방향성을 추구한다.

**잘못된 상속 예: Stack 클래스**

상속을 단순히 코드 재사용과 다형성을 목적으로 사용해서는 안된다. 상속에 대한 잘못된 예는 Stack 클래스의 예로 확인해볼 수 있다.

`Stack` 클래스의 경우 `Vector` 클래스를 상속받는다. 따라서 `Vector` 클래스의 `public`/`protected` 인터페이스는 모두 접근이 가능함을 의미한다. `Vector` 클래스의 `add` 메소드는 `public`으로 정의되어 있어 `Stack` 클래스 안에서 사용할 수 있다. 그런데 `add` 메소드를 `Stack` 클래스에서 호출하면 `Stack` 클래스 규칙에 맞지 않는 결과가 반환될 수 있다.

```java
Stack<String> stk = new Stack<>();
stk.push("1st");
stk.push("2nd");
stk.push("3rd");
stk.add(0, "4th");
 
assertEquals("4th", stk.pop()); // 에러
```

위 코드의 경우 Stack 클래스의 원소를 더하는 연산은 항상 FILO를 준수해야 한다. 허나 add 메소드로 넣은 원소는 가장 맨 앞에 위치하므로 pop연산 시 LIFO 원칙에 위배된다. 또한 Vector 클래스의 get 메소드도 Stack에서 사용할 수 있어 원소를 확인하고자 하면 pop연산으로 값을 확인해야 함에도 get 메소드를 사용하여 조회할 수 있어 역시 Stack 규칙에 어긋난다.